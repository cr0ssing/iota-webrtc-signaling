<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />

    <title>WebRTC Offerer</title>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.0/jquery.min.js"></script>
    <script src="../lib/iota.js"></script>
    <script src="https://unpkg.com/set-interval-async"></script>
  </head>

  <body>
    <h1>WebRTC Offerer</h1>

    <button id="offerRecdBtn">Stop fetching answers</button>

    <input id="copyLink" style="width: 30em;" />
    <div id="link"></div>

    <div id="chatlog"></div>

    <script>
      const setIntervalAsync = SetIntervalAsync.fixed.setIntervalAsync;
      const clearIntervalAsync = SetIntervalAsync.clearIntervalAsync;

      const cfg = {
        iceServers: [
          { urls: 'stun:stun.l.google.com:19302' },
          {
            urls: 'turn:numb.viagenie.ca',
            credential: 'muazkh',
            username: 'webrtc@live.com',
          },
        ],
      };
      const con = { optional: [{ DtlsSrtpKeyAgreement: true }] };

      const origin = window.location.protocol + '//' + window.location.host;
      const receiverUrl =
        origin +
        location.pathname.substring(0, location.pathname.lastIndexOf('/')) +
        '/receiver.html';

      /* THIS IS ALICE, THE CALLER/SENDER */

      const pc1 = new RTCPeerConnection(cfg, con);
      let dc1 = null;
      let address;
      let interval;
      const connected = [];

      const sdpConstraints = {
        optional: [],
        mandatory: {
          OfferToReceiveAudio: false,
          OfferToReceiveVideo: false,
        },
      };

      setupDC1();
      pc1.createOffer(
        function (desc) {
          pc1.setLocalDescription(
            desc,
            function () {},
            function () {}
          );
          console.log('created local offer', desc);
        },
        function () {
          console.warn("Couldn't create offer");
        },
        sdpConstraints
      );

      $('#offerRecdBtn').click(function () {
        clearIntervalAsync(interval);
      });

      function setupDC1() {
        try {
          dc1 = pc1.createDataChannel('test', { reliable: true });
          console.log('Created datachannel (pc1)');
          dc1.onopen = function (e) {
            console.log('data channel connect');

            const msg = 'ping';
            dc1.send(msg);
            writeToChatLog(msg, 'text-success');
          };
          dc1.onmessage = function (e) {
            console.log('Got message (pc1)', e.data);
            writeToChatLog(e.data, 'text-info');
          };
        } catch (e) {
          console.warn('No data channel (pc1)', e);
        }
      }

      pc1.onicecandidate = function (e) {
        // console.log('ICE candidate (pc1)', e);
        if (e.candidate == null) {
          console.log(JSON.stringify(pc1.localDescription));
          IOTA.publishOffer(pc1.localDescription)
            .then((b) => {
              console.log(b[0].hash);
              writeToChatLog('Published offer', 'text-success');
              address = b[0].address;
              const link = receiverUrl + '?bundle=' + b[0].hash;
              console.log(link);
              $('#copyLink').val(link);
              $('#link').append(`<a href="${link}" target="_blank">Join</a>`);
            })
            .then(() => {
              interval = setIntervalAsync(() => {
                console.log('Fetching answers...');
                return IOTA.fetchAnswers(address).then((answers) =>
                  answers
                    .filter((a) => connected.indexOf(a.sdp) === -1)
                    .forEach((answer) => {
                      var answerDesc = new RTCSessionDescription(answer);
                      handleAnswerFromPC2(answerDesc);
                      connected.push(answer.sdp);
                      clearIntervalAsync(interval);
                    })
                );
              }, 2000);
            });
        }
      };

      function handleOnconnection() {
        console.log('Datachannel connected');
        writeToChatLog('Datachannel connected', 'text-success');
      }

      pc1.onconnection = handleOnconnection;

      function onsignalingstatechange(state) {
        console.info('signaling state change:', state);
      }

      function oniceconnectionstatechange(state) {
        console.info('ice connection state change:', state);
      }

      function onicegatheringstatechange(state) {
        console.info('ice gathering state change:', state);
      }

      function handleAnswerFromPC2(answerDesc) {
        console.log('Received remote answer: ', answerDesc);
        writeToChatLog('Received remote answer', 'text-success');
        pc1.setRemoteDescription(answerDesc);
      }

      function handleCandidateFromPC2(iceCandidate) {
        pc1.addIceCandidate(iceCandidate);
      }

      function getTimestamp() {
        var totalSec = new Date().getTime() / 1000;
        var hours = parseInt(totalSec / 3600) % 24;
        var minutes = parseInt(totalSec / 60) % 60;
        var seconds = parseInt(totalSec % 60);

        var result =
          (hours < 10 ? '0' + hours : hours) +
          ':' +
          (minutes < 10 ? '0' + minutes : minutes) +
          ':' +
          (seconds < 10 ? '0' + seconds : seconds);

        return result;
      }

      function writeToChatLog(message, message_type) {
        document.getElementById('chatlog').innerHTML +=
          '<p class="' +
          message_type +
          '">' +
          '[' +
          getTimestamp() +
          '] ' +
          message +
          '</p>';
      }
    </script>
  </body>
</html>
